# SECCON CTF 2023 Quals

[![follow_tag](https://img.shields.io/github/followers/Daysapro?label=Seguir&style=social)](https://github.com/Daysapro) [![like_tag](https://img.shields.io/github/stars/Daysapro/cryptonomicon?label=Favorito&style=social)](https://github.com/Daysapro/cryptonomicon)

[![ctf_tag](https://img.shields.io/:CTF-2ecc71.svg?labelColor=472D27&color=472D27)]() [![public_key_tag](https://img.shields.io/:clave%20pública-2ecc71.svg?labelColor=FF0000&color=FF0000)]() [![modular_arithmetic_tag](https://img.shields.io/:aritmética%20modular-2ecc71.svg?labelColor=149AFF&color=149AFF)]()

> **16/09/2023 7:00 CEST - 17/09/2023 7:00 CEST**

Todo el código desarrollado se puede consultar en la carpeta de scripts.


## plai_n_rsa

> **183/653 soluciones | 78 puntos**

**Enunciado**
    
    I've dropped the "n" ... where is my "n" :(

**Archivos**

    problem.py

```python
import os

from Crypto.Util.number import bytes_to_long, getPrime

flag = os.getenvb(b"FLAG", b"SECCON{THIS_IS_FAKE}")
assert flag.startswith(b"SECCON{")
m = bytes_to_long(flag)
e = 0x10001
p = getPrime(1024)
q = getPrime(1024)
n = p * q
e = 65537
phi = (p-1)*(q-1)
d = pow(e, -1, phi)
hint = p+q
c = pow(m,e,n)

print(f"e={e}")
print(f"d={d}")
print(f"hint={hint}")
print(f"c={c}")
```

    problem.py

```python
e=65537
d=15353693384417089838724462548624665131984541847837698089157240133474013117762978616666693401860905655963327632448623455383380954863892476195097282728814827543900228088193570410336161860174277615946002137912428944732371746227020712674976297289176836843640091584337495338101474604288961147324379580088173382908779460843227208627086880126290639711592345543346940221730622306467346257744243136122427524303881976859137700891744052274657401050973668524557242083584193692826433940069148960314888969312277717419260452255851900683129483765765679159138030020213831221144899328188412603141096814132194067023700444075607645059793
hint=275283221549738046345918168846641811313380618998221352140350570432714307281165805636851656302966169945585002477544100664479545771828799856955454062819317543203364336967894150765237798162853443692451109345096413650403488959887587524671632723079836454946011490118632739774018505384238035279207770245283729785148
c=8886475661097818039066941589615421186081120873494216719709365309402150643930242604194319283606485508450705024002429584410440203415990175581398430415621156767275792997271367757163480361466096219943197979148150607711332505026324163525477415452796059295609690271141521528116799770835194738989305897474856228866459232100638048610347607923061496926398910241473920007677045790186229028825033878826280815810993961703594770572708574523213733640930273501406675234173813473008872562157659306181281292203417508382016007143058555525203094236927290804729068748715105735023514403359232769760857994195163746288848235503985114734813
```


### Resolución

Se presenta un sistema de cifrado [RSA](https://en.wikipedia.org/wiki/RSA_(cryptosystem)) en el no nos incluyen el módulo mientras que sí se conoce la clave privada $d$. El objetivo es encontrar el módulo $n$ para poder descifrar el mensaje:

$$m \equiv c^d \bmod n$$

Se tiene además un dato exfiltrado, $hint$:

$$hint = p + q$$

Siendo $p$ y $q$ los primos que conforman $n$, $n = p \cdot q$.

En la teoría de RSA se utiliza la [función de Euler](https://en.wikipedia.org/wiki/Euler%27s_totient_function) $\phi(n)$ para definir el sistema de la siguiente manera:

$$e \cdot d \equiv 1 \bmod \phi(n)$$

Esta función es la encargada de asegurar la propiedad de reversibilidad entre las claves $e$ y $d$:

$$c \equiv m^e \bmod n$$

$$m \equiv c^d \bmod n$$

Dentro de RSA, esta función se puede definir como:

$$\phi(n) = (p - 1) \cdot (q - 1)$$

La ecuación anterior se puede desarrollar:

$$\phi(n) = (p - 1) \cdot (q - 1)$$

$$\phi(n) = p \cdot q - p - q + 1$$

$$\phi(n) = n - (p + q) + 1$$

$$\phi(n) = n - hint + 1$$

$$n = \phi(n) + hint - 1$$

Aquí se demuestra el interés de esta función en este ejercicio. Si se consigue calcular la función de Euler, se puede obtener $n$. Volviendo a la definición:

$$e \cdot d \equiv 1 \bmod \phi(n)$$

$$e \cdot d = 1 + k \cdot \phi(n)$$

$$\phi(n) = \frac{e \cdot d - 1}{k}$$

Como la clave privada $d$ no puede ser más grande que $n$ y por tanto tampoco que $\phi(n)$ y $e = 65537$, $k$ nunca podrá ser mayor que este valor $e$. Se puede realizar un ataque de fuerza bruta desencriptando para todos los valores de $k$ hasta $k = 65537$.

$$n = \frac{e \cdot d - 1}{k} + hint - 1$$

```python
from Crypto.Util.number import long_to_bytes


e = 65537
d = 15353693384417089838724462548624665131984541847837698089157240133474013117762978616666693401860905655963327632448623455383380954863892476195097282728814827543900228088193570410336161860174277615946002137912428944732371746227020712674976297289176836843640091584337495338101474604288961147324379580088173382908779460843227208627086880126290639711592345543346940221730622306467346257744243136122427524303881976859137700891744052274657401050973668524557242083584193692826433940069148960314888969312277717419260452255851900683129483765765679159138030020213831221144899328188412603141096814132194067023700444075607645059793
hint = 275283221549738046345918168846641811313380618998221352140350570432714307281165805636851656302966169945585002477544100664479545771828799856955454062819317543203364336967894150765237798162853443692451109345096413650403488959887587524671632723079836454946011490118632739774018505384238035279207770245283729785148
c = 8886475661097818039066941589615421186081120873494216719709365309402150643930242604194319283606485508450705024002429584410440203415990175581398430415621156767275792997271367757163480361466096219943197979148150607711332505026324163525477415452796059295609690271141521528116799770835194738989305897474856228866459232100638048610347607923061496926398910241473920007677045790186229028825033878826280815810993961703594770572708574523213733640930273501406675234173813473008872562157659306181281292203417508382016007143058555525203094236927290804729068748715105735023514403359232769760857994195163746288848235503985114734813


for k in range(1, e):
    if e * d % k != 1:
        continue

    n = ((e * d - 1) // k) + hint - 1
    m = long_to_bytes(pow(c, d, n))

    if b"SECCON" in m:
        print(m)
        break
```

> **flag: SECCON{thank_you_for_finding_my_n!!!_GOOD_LUCK_IN_SECCON_CTF}**